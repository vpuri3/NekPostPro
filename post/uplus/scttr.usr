c-----------------------------------------------------------------------
c
c     Scatter face data into domain in direction idir.
c
c     idir [1,2,3] ==> [X,Y,Z]
c
c     See example below.
c-----------------------------------------------------------------------
c     Assuming deformation of the form y = f(x,z),
c
c     From usrchk()
c      
c     real u (lx1,ly1,lz1,lelv)
c    $     ua(lx1,ly1,lz1,lelv)
c
c     integer gs_sctr_hndl
c     save    gs_sctr_hndl
c     data    gs_sctr_hndl / 0 /
c
c     f     = 1
c     bctyp = 'W  '
c     nelx  = 16
c     nelx  = 32
c     nelx  = 128
c     ifld  = 1       ! Velocity field
c     idir  = 2       ! Y-Direction
c
c     call scttr(ua,u,f,bctyp,gs_sctr_hndl,nelx,nely,nelz,ifld,idir)
c
c      _________________________________________________
c      \                                                |
c       \                                               |
c        \       scatter parallel                       |
c wall--> \       to Y                                  |
c (face 1) \                                            |
c           * ------------------> *                     |
c            \        ^                                 |  ^ Z
c             \     distance to face                    |  |
c              \                                        |  |
c               \_______________________________________|  +----> Y
c
c
c-----------------------------------------------------------------------
      subroutine scttr(ua,u,f,bctyp,gs_hndl,nelx,nely,nelz,ifld,idir)
      include 'SIZE'
      include 'TOTAL'

      real ua(lx1,ly1,lz1,lelv),u(1)
      character*3 bctyp
      integer gs_hndl,idir,f

      integer nelx,nely,nelz,nel
c     integer*8 glo_num(lx1,ly1,lz1,lelv)
c     common /sctr/ glo_num,nelx,nely,nelz,nel,n

      nel  = nelfld(ifld)
      n    = nx1*ny1*nz1*nel

      if (gs_hndl.eq.0) then
c      call rzero(glo_num,n)
       call dsset(nx1,ny1,nz1)
       if (idir.eq.1) call gs_x_sctr(gs_hndl,f,bctyp,nelx,nely,nelz,nel)
       if (idir.eq.2) call gs_y_sctr(gs_hndl,f,bctyp,nelx,nely,nelz,nel)
       if (idir.eq.3) call gs_z_sctr(gs_hndl,f,bctyp,nelx,nely,nelz,nel)
      endif

      call copy(ua,u,n)

c     VERIFY GLOBAL NUMBERING
c     do i=1,n
c        ua(i,1,1,1) = glo_num(i,1,1,1)
c     enddo

      call fgslib_gs_op(gs_hndl,ua,1,1,0)

      return
      end
c-----------------------------------------------------------------------
      subroutine gs_x_sctr(gs_sctr_hndl,f,bctyp,nelx,nely,nelz,nel)
      include 'SIZE'
      include 'TOTAL'
      integer gs_sctr_hndl,f,e,ex,ey,ez,eg,nelyz
      integer*8 ex_g
      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      integer nelx,nely,nelz,nel,n
      integer*8 glo_num(lx1,ly1,lz1,lelv)
c     common /sctr/ glo_num,nelx,nely,nelz,nel,n

      if(nid.eq.0) write(6,*) 'x_sctr'

      n     = nx1*ny1*nz1*nel
      nelyz = nely*nelz
      nt    = ny1*nely*nz1*nelz

      do e=1,nel
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nelyz,1)
         ex_g = ey       ! Ensure int*8 promotion
         do k=1,nz1      ! Enumerate points in the y-z plane
         do j=1,ny1
         do i=1,nx1
            glo_num(i,j,k,e) = j+ny1*(k-1) + ny1*nz1*(ex_g-1)
            glo_num(i,j,k,e) = - glo_num(i,j,k,e)
         enddo
         enddo
         enddo
         call flag_bdry(glo_num,f,e,bctyp)
      enddo

      call fgslib_gs_setup(gs_sctr_hndl,glo_num,n,nekcomm,mp)

      return
      end
c-----------------------------------------------------------------------
      subroutine gs_y_sctr(gs_sctr_hndl,f,bctyp,nelx,nely,nelz,nel)
      include 'SIZE'
      include 'TOTAL'
      integer gs_sctr_hndl,f,e,ex,ey,ez,eg
      integer*8 ex_g
      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      integer nelx,nely,nelz,nel,n
      integer*8 glo_num(lx1,ly1,lz1,lelv)
c     common /sctr/ glo_num,nelx,nely,nelz,nel,n

      if(nid.eq.0) write(6,*) 'y_sctr'

      n  = nx1*ny1*nz1*nel

      do e=1,nel
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)            
         ex_g = (ez-1)*nelx+ex  ! Ensure int*8 promotion
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1
          glo_num(i,j,k,e) = k+nz1*(i-1) + nx1*nz1*(ex_g-1)
          glo_num(i,j,k,e) = - glo_num(i,j,k,e)
         enddo
         enddo
         enddo
         call flag_bdry(glo_num,f,e,bctyp)
      enddo

      call fgslib_gs_setup(gs_sctr_hndl,glo_num,n,nekcomm,mp)

      return
      end
c-----------------------------------------------------------------------
      subroutine gs_z_sctr(gs_sctr_hndl,f,bctyp,nelx,nely,nelz,nel)
      include 'SIZE'
      include 'TOTAL'
      integer gs_sctr_hndl,f,e,ex,ey,ez,eg,nelxy
      integer*8 ex_g
      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      integer nelx,nely,nelz,nel,n
      integer*8 glo_num(lx1,ly1,lz1,lelv)
c     common /sctr/ glo_num,nelx,nely,nelz,nel,n

      if(nid.eq.0) write(6,*) 'z_sctr'

      n     = nx1*ny1*nz1*nel
      nelxy = nelx*nely

      do e=1,nel
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelxy,1,1)
         ex_g = ex       ! Ensure int*8 promotion
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1
          glo_num(i,j,k,e) = i+nx1*(j-1) + nx1*ny1*(ex_g-1)
          glo_num(i,j,k,e) = - glo_num(i,j,k,e)
         enddo
         enddo
         enddo
         call flag_bdry(glo_num,f,e,bctyp)
      enddo

      call fgslib_gs_setup(gs_sctr_hndl,glo_num,n,nekcomm,mp)

      return
      end
c-----------------------------------------------------------------------
      subroutine flag_bdry(idx,f,e,bctyp)
      include 'SIZE'
      include 'TOTAL'
      integer*8 idx(lx1,ly1,lz1,lelv)
      integer f,e
      character*3 bctyp

c     flag points on boundary

      if(cbc(f,e,1).eq.bctyp) then
         iface  = eface1(f)     ! surface to volume shifts
         js1    = skpdat(1,iface)
         jf1    = skpdat(2,iface)
         jskip1 = skpdat(3,iface)
         js2    = skpdat(4,iface)
         jf2    = skpdat(5,iface)
         jskip2 = skpdat(6,iface)

         do j2=js2,jf2,jskip2
         do j1=js1,jf1,jskip1
            idx(j1,j2,1,e) = - idx(j1,j2,1,e)
         enddo
         enddo          
      endif
      
      return
      end
c-----------------------------------------------------------------------
c     copmuts dist in direction of idir
c-----------------------------------------------------------------------
      subroutine dist2face(d,f,bctyp,gs_sctr_hndl
     $                      ,nelx,nely,nelz,ifld,idir)
      include 'SIZE'
      include 'TOTAL'
      real d (lx1,ly1,lz1,lelv)
      real dd(lx1,ly1,lz1,lelv)
      integer n,f,ifld

      nel = nelfld(ifld)
      n   = nx1*ny1*nz1*nel

      if(idir.eq.1) call copy(dd,xm1,n)
      if(idir.eq.2) call copy(dd,ym1,n)
      if(idir.eq.3) call copy(dd,zm1,n)

      call scttr(d,dd,f,bctyp,gs_sctr_hndl,nelx,nely,nelz,ifld,idir)

      do i=1,n
         d(i,1,1,1) = abs( d(i,1,1,1)-dd(i,1,1,1) )
      enddo

      return
      end
c-----------------------------------------------------------------------
c     subroutine dist2face(d,bctyp,f,ifld)
c
cc    Based on cheap_dist() in $NEKSOURCE/core/navier5.f
cc    Computes distance from face f having bc bctyp
c
c     include 'SIZE'
c     include 'GEOM'     
c     include 'INPUT'    
c     include 'TSTEP'    
c     include 'PARALLEL'
c
c     real d(lx1,ly1,lz1,lelv)
c     character*3 bctyp
c     integer e,eg,f
c
c     nel = nelfld(ifld)
c     n = lx1*ly1*lz1*nel
c
c     call domain_size(xmin,xmax,ymin,ymax,zmin,zmax)
c
c     xmn = min(xmin,ymin)
c     xmx = max(xmax,ymax)
c     if (if3d) xmn = min(xmn ,zmin)
c     if (if3d) xmx = max(xmx ,zmax)
c
c     big = 10*(xmx-xmn)
c     call cfill(d,big,n)
c
c     nface = 2*ldim
c     do e=1,nel     ! Set d=0 on walls
c        if (cbc(f,e,ifld).eq.bctyp) call facev(d,e,f,0.,lx1,ly1,lz1)
c     enddo
c
c     do ipass=1,10000
c        dmax    = 0
c        nchange = 0
c        do e=1,nel
c          do k=1,lz1
c          do j=1,ly1
c          do i=1,lx1
c            i0=max(  1,i-1)
c            j0=max(  1,j-1)
c            k0=max(  1,k-1)
c            i1=min(lx1,i+1)
c            j1=min(ly1,j+1)
c            k1=min(lz1,k+1)
c            do kk=k0,k1
c            do jj=j0,j1
c            do ii=i0,i1
c
c             if (if3d) then
c              dtmp = d(ii,jj,kk,e) + dist3d(
c    $           xm1(ii,jj,kk,e),ym1(ii,jj,kk,e),zm1(ii,jj,kk,e)
c    $          ,xm1(i ,j ,k ,e),ym1(i ,j ,k ,e),zm1(i ,j ,k ,e))
c             else
c              dtmp = d(ii,jj,kk,e) + dist2d(
c    $           xm1(ii,jj,kk,e),ym1(ii,jj,kk,e)
c    $          ,xm1(i ,j ,k ,e),ym1(i ,j ,k ,e))
c             endif
c
c             if (dtmp.lt.d(i,j,k,e)) then
c               d(i,j,k,e) = dtmp
c               nchange = nchange+1
c               dmax = max(dmax,d(i,j,k,e))
c             endif
c            enddo
c            enddo
c            enddo
c
c          enddo
c          enddo
c          enddo
c        enddo
c        call fgslib_gs_op(gsh_fld(ifld),d,1,3,0) ! min over all elements
c        nchange = iglsum(nchange,1)
c        dmax = glmax(dmax,1)
c        if (nio.eq.0) write(6,1) ipass,nchange,dmax,b
c   1    format(i9,i12,1pe12.4,' max distance b: ',a3)
c        if (nchange.eq.0) goto 1000
c     enddo
c1000 return
c     end
c-----------------------------------------------------------------------
