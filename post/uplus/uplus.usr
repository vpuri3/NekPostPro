C-----------------------------------------------------------------------
c     In usrchk,
c     call comp_uplus(upl,ypl,vlx,vly,vlz,f,bctyp,gs_sctr_hndl
c    $                      ,nelx,nely,nelz,ifld,idir)
c
c     up,yp   : u-plus, y-plus
c     ux/y/z  : velocity fields
c     f       : face containing wall data
c     idir    : direction perpendicular to face /
c               direction to scatter data from face into domain
c               [1,2,3] ==> [x,y,z]
c     bctyp   : Boundary condition of face (char*3)
c
c     computes normal and tangential componenets of velocity,
c     shear stress on wall, drag force on wall, friction velocity,
c     y-plus.
c
c     outputs 1) shear stress vector on face,
c             2) normal, tangential velocity,
c                dist. to face, shear stress mag in volume,
c             3) u-plus, y-plus, shear stress mag in volume.
c
c     relies on lexicographical element and node ordering.
c
c-----------------------------------------------------------------------
c
c      _________________________________________________
c      \                                                |
c       \                                               |
c        \       scatter parallel                       |
c wall--> \       to Y                                  |
c (face 1) \                                            |
c           * ------------------> *                     |
c            \        ^                                 |  ^ Z
c             \     distance to face                    |  |
c              \                                        |  |
c               \_______________________________________|  +----> Y
c
c     real up(lx1,ly1,lz1,lelv)
c     real yp(lx1,ly1,lz1,lelv)
c     real ux(lx1,ly1,lz1,lelv)
c     real uy(lx1,ly1,lz1,lelv)
c     real uz(lx1,ly1,lz1,lelv)
c     integer f,idir
c     character*3 bctyp
c
c     integer gs_sctr_hndl
c     save    gs_sctr_hndl
c     data    gs_sctr_hndl / 0 /
c
c     f     = 1
c     bctyp = 'W  '
c     nelx  = 16
c     nely  = 32
c     nelz  = 128
c     idir  = 2
c     call comp_uplus(upl,ypl,vlx,vly,vlz,f,bctyp,gs_sctr_hndl
c    $                      ,nelx,nely,nelz,ifld,idir)
c
C-----------------------------------------------------------------------
      include 'scttr.usr'
C-----------------------------------------------------------------------
      subroutine comp_uplus(up,yp,ux,uy,uz,f,bctyp,gs_hndl
     $                      ,nelx,nely,nelz,ifld,idir)
      include 'SIZE'
      include 'TOTAL'

      parameter(lxyz = lx1*ly1*lz1)
      parameter(nxzf = 2*ldim)

      real up(lx1,ly1,lz1,lelv) ! U-plus
      real yp(lx1,ly1,lz1,lelv) ! Y-plus
      real ux(lx1,ly1,lz1,lelv) ! X-Velocity
      real uy(lx1,ly1,lz1,lelv) ! Y-Velocity
      real uz(lx1,ly1,lz1,lelv) ! Z-Velocity
      integer f,idir
      character*3 bctyp

ccc   PREFIX:
ccc          f   --> data present only on face (zero elsewhere)
ccc          vol --> face data scattered into domain
ccc                  in direction idir

      common /uplus/ fTx(lx1,ly1,lz1,lelv) ! shear stress X-comp
     $             , fTy(lx1,ly1,lz1,lelv) !              Y   
     $             , fTz(lx1,ly1,lz1,lelv) !              Z
     $             , fTm(lx1,ly1,lz1,lelv) !              Mag    
     $             , fNx(lx1,ly1,lz1,lelv) ! face normal  X-comp
     $             , fNy(lx1,ly1,lz1,lelv) !              Y
     $             , fNz(lx1,ly1,lz1,lelv) !              Z 
c
     $             , volTx(lx1,ly1,lz1,lelv)
     $             , volTy(lx1,ly1,lz1,lelv)
     $             , volTz(lx1,ly1,lz1,lelv)
     $             , volTm(lx1,ly1,lz1,lelv)
     $             , volNx(lx1,ly1,lz1,lelv)
     $             , volNy(lx1,ly1,lz1,lelv)
     $             , volNz(lx1,ly1,lz1,lelv)
c
     $             , utan(lx1,ly1,lz1,lelv) ! tangential velocity mag
     $             , unor(lx1,ly1,lz1,lelv) ! normal     velocity mag
     $             , d2f (lx1,ly1,lz1,lelv) ! distance to face
c
      common /ctmp1/ ur(lxyz),us(lxyz),ut(lxyz)
     $             , vr(lxyz),vs(lxyz),vt(lxyz)
     $             , wr(lxyz),ws(lxyz),wt(lxyz)

      real sij(lx1,ly1,lz1,nxzf,lelv) ! strain rate tensor
      integer e,k
      real Tmg,vsc,dsty
      real n1 ,n2 ,n3
      real s11,s12,s13
      real s21,s22,s23
      real s31,s32,s33
      real a, xdrg, ydrg, zdrg, mdrg
      real u,v,w,un,ufr,dty

      logical iifxyo,iifvo,iifpo,iifto ! for outposting

      if(nid.eq.0) write(6,*) 'in comp_uplus(...)'

      n = nx1*ny1*nz1*lelt
c
      call rzero(up,n)
      call rzero(yp,n)
c
      call rzero(fTx,n)
      call rzero(fTy,n)
      call rzero(fTz,n)
      call rzero(fTm,n)
      call rzero(fNx,n)
      call rzero(fNy,n)
      call rzero(fNz,n)
c
      call rzero(volTx,n)
      call rzero(volTy,n)
      call rzero(volTz,n)
      call rzero(volTm,n)
      call rzero(volNx,n)
      call rzero(volNy,n)
      call rzero(volNz,n)
c
      call rzero(utan,n)
      call rzero(unor,n)
      call rzero(d2f ,n)
c
      call rzero(sij,n*nxzf)

      a     = 0.                ! drag on face
      xdrg  = 0.                ! drag on face X-comp
      ydrg  = 0.                !              Y 
      zdrg  = 0.                !              Z
      mdrg  = 0.                !              Mag

      idimt  = 1
      vsc  = vdiff(lx1,ly1,lz1,nelt,idimt)
      dsty = param(1)

      ! initialize viscocity
      if (istep.eq.0) call cfill(vdiff,param(2),n)

      ! strain rate tensor
      call comp_sij(sij,nxzf,ux,uy,uz,ur,us,ut,vr,vs,vt,wr,ws,wt)

      ! get face info (initialize skpdat array)
      call dsset(nx1,ny1,nz1)

      do e=1,nelv
        if (cbc(f,e,ifld).eq.bctyp) then
          iface  = eface1(f)   ! surface to volume shifts
          js1    = skpdat(1,iface)
          jf1    = skpdat(2,iface)
          jskip1 = skpdat(3,iface)
          js2    = skpdat(4,iface)
          jf2    = skpdat(5,iface)
          jskip2 = skpdat(6,iface)

          k = 0
          do j2=js2,jf2,jskip2
          do j1=js1,jf1,jskip1
            k = k + 1
c
            n1 = unx(k,1,f,e)      ! face normal X-comp
            n2 = uny(k,1,f,e)      !             Y
            n3 = unz(k,1,f,e)      !             Z
c
            s11 = sij(j1,j2,1,1,e) ! Strain rate tensor
            s21 = sij(j1,j2,1,4,e)
            s31 = sij(j1,j2,1,6,e)
c
            s12 = sij(j1,j2,1,4,e)
            s22 = sij(j1,j2,1,2,e)
            s32 = sij(j1,j2,1,5,e)
c
            s13 = sij(j1,j2,1,6,e)
            s23 = sij(j1,j2,1,5,e)
            s33 = sij(j1,j2,1,3,e)
c
            fNx(j1,j2,1,e) = n1
            fNy(j1,j2,1,e) = n2
            fNz(j1,j2,1,e) = n3
c
            fTx(j1,j2,1,e) = -(s11*n1 + s12*n2 + s13*n3)*vsc*dsty
            fTy(j1,j2,1,e) = -(s21*n1 + s22*n2 + s23*n3)*vsc*dsty
            fTz(j1,j2,1,e) = -(s31*n1 + s32*n2 + s33*n3)*vsc*dsty
c
            Tmg =       fTx(j1,j2,1,e)*fTx(j1,j2,1,e)
            Tmg = Tmg + fTy(j1,j2,1,e)*fTy(j1,j2,1,e)
            Tmg = Tmg + fTz(j1,j2,1,e)*fTz(j1,j2,1,e)
c
            fTm(j1,j2,1,e) = SQRT(Tmg)                   ! shear stress magnitude
c
            a    = a    + area(k,1,f,e)
            xdrg = xdrg + fTx(j1,j2,1,e)*area(k,1,f,e)   ! viscous contribution to drag
            ydrg = ydrg + fTy(j1,j2,1,e)*area(k,1,f,e)
            zdrg = zdrg + fTz(j1,j2,1,e)*area(k,1,f,e)
c
            xdrg = xdrg - n1*pr(j1,j2,1,e)*area(k,1,f,e) ! pressure contribution to drag
            ydrg = ydrg - n2*pr(j1,j2,1,e)*area(k,1,f,e)
            zdrg = zdrg - n3*pr(j1,j2,1,e)*area(k,1,f,e)
c
          enddo
          enddo

        endif
      enddo
c
      call gop(a   ,Tmg,'+  ',1) ! summing over all processes
      call gop(xdrg,Tmg,'+  ',1)
      call gop(ydrg,Tmg,'+  ',1)
      call gop(zdrg,Tmg,'+  ',1)
c
      mdrg = xdrg*xdrg + ydrg*ydrg + zdrg*zdrg
      mdrg = sqrt(mdrg)
c
      if(nid.eq.0) then
         write(6,*) 'area     is', a
         write(6,*) 'xdrag    is', xdrg
         write(6,*) 'ydrag    is', ydrg
         write(6,*) 'zdrag    is', zdrg
         write(6,*) 'drag mag is', mdrg
      endif

      ! scatter face data into domain
      call scttr(volTx,fTx,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
      call scttr(volTy,fTy,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
      call scttr(volTz,fTz,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
      call scttr(volTm,fTm,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
c
      call scttr(volNx,fNx,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
      call scttr(volNy,fNy,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
      call scttr(volNz,fNz,f,bctyp,gs_hndl,nelx,nely,nelz1,ifld,idir)
c     distance in direction parallel to idir
      call dist2face(d2f,f,bctyp,gs_hndl,nelx,nely,nelz,ifld,idir)
c
      do i=1,n                                    ! compute u-plus, y-plus
         u   = vx   (i,1,1,1)
         v   = vy   (i,1,1,1)
         w   = vz   (i,1,1,1)
         n1  = volNx(i,1,1,1)
         n2  = volNy(i,1,1,1)
         n3  = volNz(i,1,1,1)
         Tmg = volTm(i,1,1,1)
c
         un = u*n1 + v*n2 + w*n3                  ! normal component of vel
         unor(i,1,1,1) = un
         utan(i,1,1,1) = u*u  + v*v  + w*w - un*un
         utan(i,1,1,1) = sqrt(utan(i,1,1,1))      ! tangential component of vel
c
         ufr = sqrt(Tmg/dsty)                     ! friction velocity
         up(i,1,1,1) = utan(i,1,1,1)/ufr
         yp(i,1,1,1) = d2f(i,1,1,1)*ufr/vsc
      enddo

c     Outpost stuff

      iifxyo = ifxyo
      iifvo  = ifvo
      iifpo  = ifpo
      iifto  = ifto

      ifxyo = .true.
      ifvo  = .true.
      ifpo  = .false.
      ifto  = .true.

      call outpost(fTx,fTy,fTz,pr,fTm,'wsh')
      call outpost(utan,unor,d2f,pr,volTm,'utn')
      ifto = .false.
      call outpost(up,yp,volTm,pr,t,'upl')

      ifxyo = iifxyo
      ifvo  = iifvo
      ifpo  = iifpo
      ifto  = iifto

      return
      end
c-------------------------------------------------------------------------------
