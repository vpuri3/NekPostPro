C-----------------------------------------------------------------------
c     In usrchk,
c     call comp_uplus(upl,ypl,vlx,vly,vlz,f,bctyp,gs_sctr_hndl
c    $                      ,nelx,nely,nelz,ifld,idir)
c
c     up,yp   : u-plus, y-plus
c     ux/y/z  : velocity fields
c     f       : face containing wall data
c     idir    : direction perpendicular to face /
c               direction to scatter data from face into domain
c               [1,2,3] ==> [x,y,z]
c     bctyp   : Boundary condition of face (char*3)
c
c     computes normal and tangential componenets of velocity,
c     shear stress on wall, drag force on wall, friction velocity,
c     y-plus.
c
c     outputs 1) shear stress vector on face,
c             2) normal, tangential velocity,
c                dist. to face, shear stress mag in volume,
c             3) u-plus, y-plus, shear stress mag in volume.
c
c     relies on lexicographical element and node ordering.
c
c-----------------------------------------------------------------------
c
c      _________________________________________________
c      \                                                |
c       \                                               |
c        \       scatter parallel                       |
c wall--> \       to Y                                  |
c (face 1) \                                            |
c           * ------------------> *                     |
c            \        ^                                 |  ^ Z
c             \     distance to face                    |  |
c              \                                        |  |
c               \_______________________________________|  +----> Y
c
c     real ux(lx1,ly1,lz1,lelv)
c     real uy(lx1,ly1,lz1,lelv)
c     real uz(lx1,ly1,lz1,lelv)
c     real up(lx1,ly1,lz1,lelv)
c     real yp(lx1,ly1,lz1,lelv)
c     integer f,ifld,idir_sctr,idir_avg
c     character*3 bctyp
c     logical ifplnr_avg,ifsample
c
c     integer gs_sctr_hndl
c     save    gs_sctr_hndl
c     data    gs_sctr_hndl / 0 /
c
c     integer gs_avg_hndl
c     save    gs_avg_hndl
c     data    gs_avg_hndl / 0 /
c
c     f          = 1
c     bctyp      = 'W  '
c     nelx       = 64
c     nely       = 16
c     nelz       = 32
c     ifld       = 1
c     idir_sctr  = 2
c     idir_avg   = 3
c     ifplnr_avg = .true. ! average over homogeneous direction idir_avg
c     ifsample  = .true.
c
c     call comp_uplus(up,yp,ux,uy,uz,f,bctyp,gs_sctr_hndl,gs_avg_hndl
c    $      ,nelx,nely,nelz,ifld,idir_sctr,idir_avg,ifplnr_avg,ifsample)
c
C-----------------------------------------------------------------------
      include 'scttr.usr'
c     include 'plavg.usr'
C-----------------------------------------------------------------------
      subroutine comp_uplus(up,yp,ux,uy,uz,f,bctyp,gs_hndl1,gs_hndl2,
     $              nelx,nely,nelz,ifld,idir1,idir2,ifplnr_avg,ifsample)

      include 'SIZE'
      include 'TOTAL'
      include 'UPLUS'

      real up(lx1,ly1,lz1,lelv) ! U-plus
      real yp(lx1,ly1,lz1,lelv) ! Y-plus
      real ux(lx1,ly1,lz1,lelv) ! X-Velocity
      real uy(lx1,ly1,lz1,lelv) ! Y-Velocity
      real uz(lx1,ly1,lz1,lelv) ! Z-Velocity
      integer f,ifld,idir1,idir2,gs_hndl1,gs_hndl2
      integer nelx,nely,nelz
      character*3 bctyp
      logical ifplnr_avg,ifsample

      common /ctmp1/ ur(lxyz),us(lxyz),ut(lxyz) ! used to compute sij
     $             , vr(lxyz),vs(lxyz),vt(lxyz)
     $             , wr(lxyz),ws(lxyz),wt(lxyz)

      real sij(lx1,ly1,lz1,nxzf,lelv) ! strain rate tensor
      integer e,k,ntot
      real Tmg,vsc,dsty
      real n1 ,n2 ,n3
      real s11,s12,s13
      real s21,s22,s23
      real s31,s32,s33
      real a, xdrg, ydrg, zdrg, mdrg
      real u,v,w,un,ufr

      logical iifxyo,iifvo,iifpo,iifto ! for outposting

      if(nid.eq.0) write(6,*) 'in comp_uplus(...)'
c
      ntot = lx1*ly1*lz1*nelv
c
      call rzero(up,ntot)
      call rzero(yp,ntot)
c
      call rzero(fNx,ntot)
      call rzero(fNy,ntot)
      call rzero(fNz,ntot)
      call rzero(fTx,ntot)
      call rzero(fTy,ntot)
      call rzero(fTz,ntot)
      call rzero(fTm,ntot)
      call rzero(fUf,ntot) ! friction vel on face
c
      call rzero(volNx,ntot)
      call rzero(volNy,ntot)
      call rzero(volNz,ntot)
      call rzero(volTm,ntot)
      call rzero(volUf,ntot) ! friction vel in vol
c
      call rzero(utn,ntot)
      call rzero(d2f,ntot)
c
      call rzero(uxa,ntot)
      call rzero(uya,ntot)
      call rzero(uza,ntot)
      call rzero(pra,ntot)
      call rzero(Tma,ntot)
      call rzero(Ufa,ntot) ! avg friction vel
c
      call rzero(sij,ntot*nxzf)

      a     = 0.                ! drag on face
      xdrg  = 0.                ! drag on face X-comp
      ydrg  = 0.                !              Y 
      zdrg  = 0.                !              Z
      mdrg  = 0.                !              Mag
c
      idimt  = 1
      vsc  = vdiff(lx1,ly1,lz1,nelt,idimt)
      dsty = param(1)

      ! initialize viscocity
      if (istep.eq.0) call cfill(vdiff,param(2),ntot)

      ! strain rate tensor
      call comp_sij(sij,nxzf,ux,uy,uz,ur,us,ut,vr,vs,vt,wr,ws,wt)

      ! get face info (initialize skpdat array)
      call dsset(nx1,ny1,nz1)

      do e=1,nelv
        if (cbc(f,e,ifld).eq.bctyp) then
          iface  = eface1(f)   ! surface to volume shifts
          js1    = skpdat(1,iface)
          jf1    = skpdat(2,iface)
          jskip1 = skpdat(3,iface)
          js2    = skpdat(4,iface)
          jf2    = skpdat(5,iface)
          jskip2 = skpdat(6,iface)

          k = 0
          do j2=js2,jf2,jskip2
          do j1=js1,jf1,jskip1
            k = k + 1
c
            n1 = unx(k,1,f,e)      ! face normal X-comp
            n2 = uny(k,1,f,e)      !             Y
            n3 = unz(k,1,f,e)      !             Z
c
            s11 = sij(j1,j2,1,1,e) ! Strain rate tensor
            s21 = sij(j1,j2,1,4,e)
            s31 = sij(j1,j2,1,6,e)
c
            s12 = sij(j1,j2,1,4,e)
            s22 = sij(j1,j2,1,2,e)
            s32 = sij(j1,j2,1,5,e)
c
            s13 = sij(j1,j2,1,6,e)
            s23 = sij(j1,j2,1,5,e)
            s33 = sij(j1,j2,1,3,e)
c
            fNx(j1,j2,1,e) = n1
            fNy(j1,j2,1,e) = n2
            fNz(j1,j2,1,e) = n3
c
            fTx(j1,j2,1,e) = -(s11*n1 + s12*n2 + s13*n3)*vsc
            fTy(j1,j2,1,e) = -(s21*n1 + s22*n2 + s23*n3)*vsc
            fTz(j1,j2,1,e) = -(s31*n1 + s32*n2 + s33*n3)*vsc
c
            Tmg =       fTx(j1,j2,1,e)*fTx(j1,j2,1,e)
            Tmg = Tmg + fTy(j1,j2,1,e)*fTy(j1,j2,1,e)
            Tmg = Tmg + fTz(j1,j2,1,e)*fTz(j1,j2,1,e)
            Tmg = sqrt(Tmg)
c
            fTm(j1,j2,1,e) = Tmg                   ! shear stress mag
            fUf(j1,j2,1,e) = sqrt(Tmg/dsty)        ! friction velocity
c
            a    = a    + area(k,1,f,e)
            xdrg = xdrg + fTx(j1,j2,1,e)*area(k,1,f,e)   ! viscous drag
            ydrg = ydrg + fTy(j1,j2,1,e)*area(k,1,f,e)
            zdrg = zdrg + fTz(j1,j2,1,e)*area(k,1,f,e)
c
c           xdrg = xdrg - n1*pr(j1,j2,1,e)*area(k,1,f,e) ! pressure drag
c           ydrg = ydrg - n2*pr(j1,j2,1,e)*area(k,1,f,e)
c           zdrg = zdrg - n3*pr(j1,j2,1,e)*area(k,1,f,e)

          enddo
          enddo

        endif
      enddo
c
      call gop(a   ,Tmg,'+  ',1) ! summing over all processes
      call gop(xdrg,Tmg,'+  ',1)
      call gop(ydrg,Tmg,'+  ',1)
      call gop(zdrg,Tmg,'+  ',1)
c
      mdrg = xdrg*xdrg + ydrg*ydrg + zdrg*zdrg
      mdrg = sqrt(mdrg)
c
      if(nid.eq.0) then
         write(6,*) 'area     is', a
         write(6,*) 'xdrag    is', xdrg
         write(6,*) 'ydrag    is', ydrg
         write(6,*) 'zdrag    is', zdrg
         write(6,*) 'drag mag is', mdrg
      endif
c
      ! scatter face data into domain
      call scttr(volNx,fNx,f,bctyp,gs_hndl1,nelx,nely,nelz1,ifld,idir1)
      call scttr(volNy,fNy,f,bctyp,gs_hndl1,nelx,nely,nelz1,ifld,idir1)
      call scttr(volNz,fNz,f,bctyp,gs_hndl1,nelx,nely,nelz1,ifld,idir1)
      call scttr(volTm,fTm,f,bctyp,gs_hndl1,nelx,nely,nelz1,ifld,idir1)
      call scttr(volUf,fUf,f,bctyp,gs_hndl1,nelx,nely,nelz1,ifld,idir1) ! friction velocity
c
      ! distance in direction parallel to idir
      call dist2face(d2f,f,bctyp,gs_hndl1,nelx,nely,nelz,ifld,idir1)
c
      if(ifplnr_avg) then
       if(nid.eq.0) write(6,*) "averaging in direction ", idri2
c
       call plane_avg_tensor(uxa,ux,gs_hndl2,nelx,nely,nelz,ifld,idir2)
       call plane_avg_tensor(uya,uy,gs_hndl2,nelx,nely,nelz,ifld,idir2)
       call plane_avg_tensor(uza,uz,gs_hndl2,nelx,nely,nelz,ifld,idir2)
       call plane_avg_tensor(pra,pr,gs_hndl2,nelx,nely,nelz,ifld,idir2)
       call plane_avg_tensor(Tma,volTm,gs_hndl2,nelx,nely,nelz,ifld
     $                                                          ,idir2)
       call plane_avg_tensor(Ufa,volUf,gs_hndl2,nelx,nely,nelz,ifld
     $                                                          ,idir2)
      else
         call copy(uxa,ux,ntot)
         call copy(uya,uy,ntot)
         call copy(uza,uz,ntot)
         call copy(pra,pr,ntot)
         call copy(Tma,volTm,ntot)
         call copy(Ufa,volUf,ntot)
      endif
c
      do i=1,ntot                                 ! u-plus,y-plus
         u   = uxa  (i,1,1,1)
         v   = uya  (i,1,1,1)
         w   = uza  (i,1,1,1)
         n1  = volNx(i,1,1,1)
         n2  = volNy(i,1,1,1)
         n3  = volNz(i,1,1,1)
         Tmg = Tma  (i,1,1,1)
c
c        ufr = Ufa  (i,1,1,1)                     ! =plnr_avg(sqrt(Tmg/rho))
         ufr = sqrt(Tmg/dsty)                     ! =sqrt(plnr_avg(Tmg)/rho)
c
         un = u*n1 + v*n2 + w*n3                  ! normal component magniture
         un = u*u  + v*v  + w*w - un*un
         un = sqrt(un)
         utn(i,1,1,1) = un                        ! tangential component magnitude
c
         up(i,1,1,1) = utn(i,1,1,1)/ufr
         yp(i,1,1,1) = d2f(i,1,1,1)*ufr/vsc
      enddo

      ! Outpost

      iifxyo = ifxyo
      iifvo  = ifvo
      iifpo  = ifpo
      iifto  = ifto
c
      ifxyo = .true.
      ifvo  = .true.
      ifpo  = .true.
      ifto  = .true.
c
      call outpost(fTx,fTy,fTz,fTm,Tma,'wsh')
      call outpost(up,yp,utn,volTm,d2f,'upl')
c
      if(ifplnr_avg) call outpost(ux,uy,uz,pra,t,'pla')
c
      ifxyo = iifxyo
      ifvo  = iifvo
      ifpo  = iifpo
      ifto  = iifto
c
      if(ifsample) call sample(up,yp,Tma,d2f,utn,'upl',
     $                      'upAvg','ypAvg','TmAvg','d2f','utn')
c
      return
      end
c------------------------------------------------------------------------






