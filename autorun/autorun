#!/bin/bash
##----------------------------------------------------##
# runs nek cases in succession
#
# INPUT: $1: case name
#        $2: folder base name
#        $3: # of folder to start from
#        $4: # of jobs to run
#
# EXAMPLE
#        $ ./autorun smoothWavyWall r 7 9
# will execute 9 consecutive runs of case smoothWavyWall
# and save then in folders r7,r8,..,r15
##----------------------------------------------------##

email="vpuri3@illinois.edu" # email log after queuing
res="restart0.f00001"       # name of restart file
rsfx="0.f00001"             # suffix of output file to restart from.
                            #      if "0.f00000" then restarts from
                            #      last file in directory.
bsfx="0.f00001"             # suffix of output file to read budgets from.
                            #      if "0.f00000" don't read budgets.
sub="my_nekqsub"            # job submission script
nnodes="256"                # # of nodes

##-------------------------------------------------------------------------##
##-------------------------------------------------------------------------##

case=$1
base=$2
num=$3
njobs=$4

me=$(whoami)

dir=$PWD
log=$dir/run.log

function send_log { mail -s "$case autorun" $email < $log; }

if [ ! -f $log ]; then
    touch $log
fi
						              
echo "##############################################"         |& tee -a $log
echo "##############################################"         |& tee -a $log
echo "##############################################"         |& tee -a $log
echo $(date -R)                                               |& tee -a $log
echo "Starting new session in directory $dir."                |& tee -a $log
echo "Running case $case from $base$num $njobs times."        |& tee -a $log
echo "Storing log in $log."                                   |& tee -a $log
							      

findrsfx=false
if [ "$rsfx" = "0.f00000" ]; then
    findrsfx=true
    echo "rsfx=$rsfx. Restart from last output file."         |& tee -a $log
fi

budgets=true
if [ "$bsfx" = "0.f00000" ]; then
    budgets=false
    echo "bsfx=$bsfx. No budgets."                            |& tee -a $log
fi

for ((i=1; i<=$njobs; i++)); do
    echo "#--------------------------------------------#"     |& tee -a $log
    echo "#------------------ RUN $i -------------------#"    |& tee -a $log
    echo "#--------------------------------------------#"     |& tee -a $log
    echo $(date -R)                                           |& tee -a $log


#   Organization
    dir0=$dir/$base$num
    if [ $i = 1 ]; then
	dir1=$dir0
	echo "starting from $dir1"                            |& tee -a $log
    else
	num=$((num+1))
	dir1=$dir/$base$num

#	checks
	if [ ! -f $dir0/$case$"0.f00001" ]; then
 	    echo "ABORT: $dir0 does not have output files."   |& tee -a $log
 	    send_log; exit 1
	fi
	if [ "$budgets" = true ]; then
	    if [ ! -f $dir0/i01$case$bsfx ]; then
 		echo "ABORT: no i01$case$bsfx in $dir0."      |& tee -a $log
 		send_log; exit 1
	    fi
	fi

#	copying directories.
	echo "copying $dir0 to $dir1"                         |& tee -a $log
	cp -r $dir0 $dir1                                     |& tee -a $log
	if [ $? != 0 ]; then		                  
	    echo "ABORT: error in copying $dir0 to $dir1."    |& tee -a $log
	    send_log; exit 1
	fi

#	changing write permission for $dir0
#       echo "changing write permissions for $dir0"           |& tee -a $log
#       cd $dir0
#       for f in $dir0; do
#           [ -L "$f" ] && cp --remove-destination "$(readlink "$f")" "$f"]
#       done
#       chmod -R -wx $dir0                                    |& tee -a $log
    
    fi

    cd  $dir1

#   updating restart
    if [ "$findrsfx" = true ]; then
	echo "finding latest output file in $dir1"            |& tee -a $log
	rsfx=$(ls -t $case"0.f"* | head -1)
	rsfx=${rsfx:${#rsfx}-8:8}
	echo "latest output file is $case$rsfx."              |& tee -a $log
    fi

    echo "removing old logs and updating restart"             |& tee -a $log
    rm $res *.cobaltlog *.error *.output *log* *out*          |& tee -a $log
    mv -v $case$rsfx $res                                     |& tee -a $log
    rm $case"0.f00"*                                          |& tee -a $log
						            
    echo "restarting from $res"                               |& tee -a $log
    head -c 130 $res                                          |& tee -a $log
    echo -e "\n"                                              |& tee -a $log

    if [ $? != 0 ]; then		                      
	echo "ABORT: something wrong with $dir1/$res."        |& tee -a $log
	send_log; exit 1
    fi

    if [ "$budgets" = true ]; then
	echo "reading budgets from i##$case$bsfx"             |& tee -a $log
	head -c 130 i01$case$bsfx                             |& tee -a $log
	echo -e "\n"                                          |& tee -a $log
    fi

    echo "compiling..."                                       |& tee -a $log
    echo "using makenek " $(which makenek)                    |& tee -a $log
    makenek $case                                              &>> /dev/null

    if [ ! -f $dir1/nek5000 ]; then
	echo "ABORT: compilation failed in $dir1 ."           |& tee -a $log
	echo "appending compiler.out to log."                 |& tee -a $log
	$dir1/compiler.out                                           >> $log
	send_log; exit 1
    fi						       
						       
    echo "compilation successful."                            |& tee -a $log
#   tail -c 300 $dir1/compiler.out                            |& tee -a $log
    ./$sub $case $nnodes                                      |& tee -a $log
					                      
    if [ $? != 0 ]; then
	echo "ABORT: could not queue job."                    |& tee -a $log
	send_log; exit 1
    fi

    echo "successfully queued job"                            |& tee -a $log
    sleep 10
    qstat --header JobId:User:RunTime:WallTime:State:Location |& tee -a $log

    sleep 60
    while [ ! -f $dir1/logfile ]; do
	echo $(date -R)                                       |& tee -a $log
	echo "waiting in queue"                               |& tee -a $log
	qstat --header JobId:RunTime:State:Location -u $me    |& tee -a $log
	sleep 300
    done
   
    echo "job is running"                                     |& tee -a $log
 
    sleep 300
    dead=$(tail logfile)
    if echo $dead | grep -Fq "dying"; then
	echo "ABORT: job died before its time."               |& tee -a $log
	echo "appending tail of logfile to run.log"           |& tee -a $log
	tail -c 1000 $dir1/logfile                            |& tee -a $log
	send_log; exit 1
    fi

    echo "all is good. goodnight."                            |& tee -a $log
    send_log
    sleep 7000
    echo $(date -R)                                           |& tee -a $log
    echo "long time no see? time for next run"                |& tee -a $log
done
